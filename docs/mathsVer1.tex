\documentclass{article}
% \usepackage[document]{ragged2e}
% \usepackage[margin=1in]{geometry}

\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}
\usepackage{longtable}

\title{egk-mixnet-maths DRAFT}
\author{John Caron}
\date{1/17/2024}

\begin{document}

\maketitle

Preliminary explorations of mixnet implementations to be used with
the ElectionGuard Kotlin library \cite{Caron23}. \par

The math here mostly recapitulates the work of Wikström \cite{Wikstr22}; Haenni
et. al. \cite{Haenni23} \cite{Haenni17}, in explaining the Terelius / Wikström (TW)
mixnet algorithm\cite{Wikstr10}\cite{Wikstr09}; and the work of Haines \cite{Haines19}
that gives a formal proof of security of TW when the shuffle involves
vectors of ciphertexts. \par

Instead of psuedocode, the Kotlin library code acts as the implementation
of the math described here. It can act as a reference and comparison
for ports to other languages. 

\pagebreak 

\section{Definitions}

\subsection{The ElectionGuard Group}
\begin{itemize}
\item $Z=\{...,-3,-2,-1,0,1,2,3,...\}$ is the set of integers. 
\item $Z_{n}=\{0,1,2,...,n-1\}$ is the ring of integers modulo n. 
\item $Z_{n}^{*}$ is the multiplicative subgroup of $Z_{n}$ that consists
of all invertible elements modulo n. When p is a prime, $Z_{p}^{*}=\{1,2,3,...,p-1\}$ 
\item $Z_{p}^{r}$ is the set of r-th-residues in $Z_{p}^{*}$ . Formally,
$Z_{p}^{r}=\{y\in Z_{p}^{*}$ for which there exists $x\in Z_{p}^{*}$
where $y=x^{r}$ mod p\}. When p is a prime for which p \textminus{}
1 = q {*} r with q a prime that is not a divisor of the integer r,
then $Z_{p}^{r}$ is an order-q cyclic subgroup of $Z_{p}^{*}$ ,
and for any $y\in Z_{p}^{*}$ , $y\in Z_{p}^{r}$ if and only if $y^{q}$
mod p = 1. 
\end{itemize}

The ElectionGuard Kotlin library \cite{Caron23} and ElectionGuard 2.0 specification \cite{Benaloh23} is used for the cryptography primitives, in particular the
parameters for $Z_{p}^{r}$, the variant of ElGamal encryption described
next, and the use of HMAC-SHA-256 for hashing

\subsection{ElGamal Encryption and Reencryption}

\begin{align*}
(1.2a)\\
Encr(m,\xi)=(g^{\xi},K^{m+\xi})=(a,b)\\
Encr(0,\xi')=(g^{\xi'},K^{\xi'})\\
\\
(1.2b)\\
(a,b)*(a',b')=(a*a',b*b')\\
Encr(m,\xi)*Encr(m',\xi')=(g^{\xi+\xi'},K^{m+m'+\xi+\xi'})=Encr(m+m',\xi+\xi')\\
\\
(1.2c)\\
(a,b)^{k}=(a^{k},b^{k})\\
Encr(m,\xi)^{k}=(g^{\xi*k},K^{(m*k+\xi*k)})=Encr(m*k,\xi*k)\\
\\
(1.2d)\\
\prod_{j=1}^{n}Encr(m_{j},\xi_{j})=(g^{\sum_{j=1}^{n}\xi_{j}},K^{\sum_{j=1}^{n}m_{j}+\sum_{j=1}^{n}\xi_{j}})=Encr(\sum_{j=1}^{n}m_{j},\sum_{j=1}^{n}\xi_{j})\\
\prod_{j=1}^{n}Encr(m_{j},\xi_{j})^{k_{j}}=Encr(\sum_{j=1}^{n}(m_{j}*k_{j}),\sum_{j=1}^{n}(\xi_{j}*k_{j}))\\
\\
(1.2e)\\
ReEncr(m,r)=(g^{\xi+r},K^{m+\xi+r})=Encr(0,r)*Encr(m,\xi)\\
ReEncr(m,r)^{k}=Encr(0,r*k)*Encr(m*k,\xi*k)\\
\\
(1.2f)\\
\prod_{j=1}^{n}ReEncr(e_{j},r_{j})=(g^{\sum_{j=1}^{n}(\xi_{j}+r_{j})},K^{\sum_{j=1}^{n}(m_{j}+\xi_{j}+r_{j})})\\
=ReEncr(\prod_{j=1}^{n}e_{j},\sum_{j=1}^{n}r_{j})\\
(1.2g)\\
\prod_{j=1}^{n}ReEncr(m_{j},r_{j})^{k_{j}}=\prod_{j=1}^{n}Encr(0,r_{j}*k_{j})*\prod_{j=1}^{n}Encr(m_{j}*k_{j},\xi_{j}*k_{j})\\
=Encr(0,\sum_{j=1}^{n}(r_{j}*k_{j}))*\prod_{j=1}^{n}Encr(m_{j},\xi_{j})^{k_{j}}\\
\end{align*}

Let
\begin{itemize}
\item $e_{j}=Encr(m_{j},\xi_{j})$ 
\item $re_{j}=ReEncr(m_{j},r_{j})=ReEncr(e_{j},r_{j})=Encr(0,r_{j})*e_{j}$ 
\end{itemize}

then

\begin{align*}
re_{j} & =Encr(0,r_{j})*e_{j}\\
\prod_{j=1}^{n}re_{j}^{k_{j}} & =\prod_{j=1}^{n}Encr(0,r_{j})^{k_{j}}*\prod_{j=1}^{n}e_{j}^{k_{j}}\\
 & =Encr(0,\sum_{j=1}^{n}(r_{j}*k_{j}))*\prod_{j=1}^{n}e_{j}^{k_{j}} \text{,    (Equation\ 1)}\\
\end{align*}

\subsection{Permutations}

A \emph{permutation} is a bijective map $\psi:{1..N}\to{1..N}$. We
use \textbf{px} to mean the permutation of a vector \textbf{x}, \textbf{px}
= $\psi(\textbf{x})$, so that $x_{i}$ = $px_{j}$, where $i={\psi(j)}$
and $j={\psi^{-1}(i)}$. $x_{i}=px_{\psi^{-1}(i)}$, $px_{j}=x_{\psi(j)}$,

A \emph{permutation} $\psi$ has a \emph{permutation matrix} $B_{\psi}$
, where $b_{ij}$ = 1 if $\psi(i)$ = j, otherwise 0. Note that $\psi(\textbf{x})$
= \textbf{px} = B\textbf{x} (matrix multiply).

If $B_{\psi}$ = ($b_{ij}$) is an n-by-n matrix over$Z_{q}$ and
\textbf{x} = $(x_{1},...,x_{n})$ a vector of N independent variables,
then $B_{\psi}$ is a permutation matrix if and only

\begin{align*}
\sum_{i=1}^{n}b_{ij} & =1 \text{, for all j         (Equation 1)}\\
\sum_{i=1}^{n}\sum_{j=1}^{n}b_{ij}x_{i} & =\sum_{i=1}^{n}x_{i}\text{    (Equation 2)}
\end{align*}

\pagebreak
\section{Verificatum}

Derived mostly from \cite{Verificatum} and \cite{Wikstr22}.

\subsection*{Pedersen Commitments}

For a set of messages $\textbf{m}=(m_{1}..m_{n})\in Z_{q}$, the \emph{Pedersen
committment} to $\textbf{m}$ is

\begin{align*}
Commit(\textbf{m},cr)=g^{cr}*h_{1}^{m_{1}}*h_{2}^{m_{2}}*..h_{n}^{m_{n}}=g^{cr}*\prod_{i=1}^{n}h_{i}^{m_{i}}
\end{align*}

where ($g,\textbf{h}$) are generators of $Z_{p}^{r}$ with randomization
nonce $cr\in Z_{q}$. (section 1.2 of )

If $\textbf{b}_{i}$ is the $i^{th}$ column of $B_{\psi}$, then
the \emph{permutation commitment to $\psi$} is defined as the vector
of committments to its columns:

\[
Commit(\psi,\textbf{cr})=(Commit(\textbf{b}_{1},cr_{1}),Commit(\textbf{b}_{2},cr_{2}),..Commit(\textbf{b}_{N},cr_{N}))=
\]

where

\begin{align*}
c_{j}=Commit(\textbf{b}_{j},cr_{j})=g^{cr_{j}}*\prod_{i=1}^{n}h_{i}^{b_{ij}}=g^{cr_{j}}*h_{i},\ for\ i=\psi^{-1}(j)
\end{align*}


\subsection*{Definitions}

Let
\begin{itemize}
\item n = number of rows (eg ballots) 
\item width = number of ciphertexts in each row 
\item $W$ = matrix of ciphertexts (n x width), with entries $w_{i,j}$
; its row vectors of width ciphertexts are $\vec{w}_{i},i=1..n$ ;
and its column vectors of n ciphertexts are $\vec{w}_{j},j=1..width$ 
\item $W^{\prime}$ = matrix of shuffled and reencrypted ciphertexts (n
x width), with entries, row vectors and column vectors $w_{i,j}^{\prime},\vec{w^{\prime}}_{i},\vec{w^{\prime}}_{j}$
respectively 
\item $R$ = matrix of reencryption nonces $\in Z_{q}$ (unpermuted) 
\item $\psi$ = permutation function 
\item $\psi^{-1}$ = inverse permutation function 
\item $\vec{h}$ = generators of $Z_{p}^{r},h_{0}=\vec{h}_{1}$ 
\end{itemize}
We use one-based array indexing for notational simplicity.

\subsection*{Shuffle}

Choose R = (n x width) matrix of reencryption random nonces, ie separate
nonces for each ciphertext. The the shuffle of $W$ is:

\[
W^{\prime} = \psi^{-1}(Reencrypt(W, R))
\]



\subsection*{Proof Construction}

The Proof equations are reverse engineered from reading the Verificatum
code. AFAIK, there is no documentation of these except in the Verificatum
code, in particular not in \cite{Wikstr22}, although likely they are implied
in \cite{Wikstr10} using different notation. In any case, these equations
are implemented in the kotlin library \emph{ShuffleProver} and verify
with \emph{ShuffleVerifier}. The \emph{ShuffleVerifier} also verifies
against the proofs output by Verificatum itself, leading to some confidence
that these equations capture the TW algorithm as implemented in Verificatum.

\subsubsection*{Commitment to permutation}

Choose a vector of \emph{n} random permutation nonces $\vec{pn}$.\\
 Form permutation commitments $\vec{u}$ that will be public:

\[
u_{j}=g^{pn_{j}}\cdot h_{i},\ \ \ j=\psi(i)\ \ \ TODO
\]

\subsubsection*{Commitment to shuffle}

Compute \emph{n} nonces $\vec{e}$ that will be public. Let ${e^{\prime}}$
= $\psi^{-1}(\vec{e})$.\\
 Choose vectors of \emph{n} random nonces $\vec{b},\vec{\beta},\vec{eps}$
.\\
 Choose random nonces $\alpha,\gamma,\delta$ .

Form the following values $\in Z_{p}^{r}$:

\begin{align*}
A^{\prime} & =g^{\alpha}\prod_{i=1}^{n}h_{i}^{eps_{i}}\\
B_{i} & =g^{b_{i}}(B_{i-1})^{e_{i}^{\prime}},\ where\ B_{0}=g^{b_0} h_0^{e_{0}^{\prime}},\ i=1..n\\
B_{1}^{\prime}&=g^{\beta_1} h_0^{eps_1},\ B_{i}^{\prime} =g^{\beta_{i}}(B_{i-1})^{eps_{i}},\ i=2..n\\
C^{\prime} & =g^{\gamma}\\
D^{\prime} & =g^{\delta}\\
\end{align*}

\subsubsection*{Commitment to exponents}

Choose \emph{width} random nonces $\vec{\phi}$ .

Form the following ciphertext values:

\begin{align*}
F_{j}^{\prime} & =Encr(0,-{\phi_{j}})\cdot\prod_{i=1}^{n}(w_{i,j}^{\prime})^{eps_{i}}\ ,\ j=1..width\\
\end{align*}

Note that $\vec{F^{\prime}}$ has \emph{width} components, one for
each of the column vectors of $W^{\prime}=\vec{w^{\prime}}_{j}$.
For each column vector, form the component-wise product of it exponentiated
with $\vec{eps}$. We can use any of the following notations:

\begin{align*}
 & =\prod_{i=1}^{n}(w_{i,j}^{\prime})^{eps_{i}},\ j=1..width\\
 & =\prod_{i=1}^{n}(\vec{w^{\prime}}_{j})_{i}^{eps_{i}}\\
 & =\prod_{i=1}^{n}(W^{\prime})^{eps}\\
\end{align*}

This disambiguates the equations in Algorithm 19 of \cite{Wikstr22}, for example:
$\prod w_{i}^{e_{i}}$. and $\prod(w_{i}^{\prime})^{k_{E,i}}$.

\subsubsection*{Reply to challenge v:}

A challenge v $\in Z_{q}$ is given, and the following values $\in Z_{q}$
are made as reply:

\begin{align*}
k_{A} & =v\ \cdot<\vec{pn},\vec{e}>+\alpha\\
\vec{k_{B}} & =v\cdot\vec{b}+\vec{\beta}\\
k_{C} & =v\cdot\sum_{i=1}^{n}pn_{i}+\gamma\\
k_{D} & =v\cdot d+\delta\\
\vec{k_{E}} & =v\cdot\vec{e^{\prime}}+\vec{eps}\\
\end{align*}

and

\begin{align*}
Let\ \vec{R}_{j} & =\ jth\ column\ of\ reencryption\ nonces\ R\\
k_{F,j} & =v\ \cdot<\vec{R}_{j},\vec{e}^{\prime}>+\ \phi_{j}\ ,\ j=1..width\\
\end{align*}

where < , > is the inner product of two vectors.

\subsection*{ProofOfShuffle Data Structure}
\begin{verbatim}
data class ProofOfShuffle(
    val mixname: String,
    val u: VectorP, // permutation commitment

    // Commitment of the Fiat-Shamir proof.
    val B: VectorP, 
    val Ap: ElementModP, 
    val Bp: VectorP, 
    val Cp: ElementModP, 
    val Dp: ElementModP, 
    val Fp: VectorCiphertext, // width

    // Reply of the Fiat-Shamir proof.
    val kA: ElementModQ,
    val kB: VectorQ,
    val kC: ElementModQ,
    val kD: ElementModQ,
    val kE: VectorQ,
    val kF: VectorQ, // width
)
\end{verbatim}

\subsection*{Proof Verification}

The following equations are taken from Algorithm 19 of \cite{Wikstr22} and
checked against the Verificatum implementation. The main ambiguity
is in the meaning of $\prod_{i=1}^{n}w_{i}^{e_{i}}$ and $\prod_{i=1}^{n}(w_{i}^{\prime})^{k_{E,i}}$
in steps 3 and 5. These are interpreted as a short hand for \emph{width}
equations on the column vectors of $W$ and $W^{\prime}$, respectively,
as detailed in \emph{committment to exponents} section above.

The Verifier is provided with:

\begin{itemize}
\item n = number of rows 
\item width = number of ciphertexts in each row 
\item $W$ = rows of ciphertexts (n x width) 
\item $W^{\prime}$ = shuffled and reencrypted rows of ciphertexts (n x width) 
\item the ProofOfShuffle 
\end{itemize}

The $\vec{h}$ (generators), $\vec{e}$ nonces, and challenge are
deterministically recalculated. This prevents those from being carefully
chosen to subvert the proof.

The following values $\in Z_{p}^{r}$ are computed:

\begin{align*}
A & =\prod_{i=1}^{n}u_{i}^{e_{i}}\\
C & =(\prod_{i=1}^{n}u_{i})/(\prod_{i=1}^{n}h_{i})\\
D & =B_{n}\cdot h_{0}^{\prod_{i=1}^{n}e_{i}}\\
\end{align*}

and

\begin{align*}
F_{j} & =\prod_{i=1}^{n}(w_{i,j})^{e_{i}}\ ,\ j=1..width\\
\end{align*}

Then the following are checked, and if all are true, the verification
succeeds:

\begin{align*}
A^{v}\cdot A^{\prime} & =g^{k_{A}}\prod_{i=1}^{n}h_{i}^{k_{E,i}}\\
B_{i}^{v}\cdot B_{i}^{\prime} & =g^{k_{B,i}}(B_{i-1})^{k_{E,i}},\ where\ B_{0}=h_{0},\ i=1..n\\
C^{v}\cdot C^{\prime} & =g^{k_{C}}\\
D^{v}\cdot D^{\prime} & =g^{k_{D}}\\
\end{align*}

and

\begin{align*}
F_{j}^{v}F_{j}^{\prime} & =Encr(0,-k_{F,j})\prod_{i=1}^{n}(w_{i,j}^{\prime})^{k_{E,i}},\ j=1..width\\
\end{align*}

\subsection*{issues}

\paragraph{Calculation of $\vec{h}$ (generators), $\vec{e}$ and the
challenge nonces} are highly dependent on the VMN implementation.
The verifier is expected to independently generate, ie they are not
part of the ProofOfShuffle output.

\paragraph{generators} may need to be carefully chosen, see section 6.8
of vmnv: "In particular, it is not acceptable to derive exponents
x1 , . . . , xN in Zq and then define $h_i = g^{x_i}$"

\section{OpenCHVote}

This follows the OpenCHVote implementation \cite{OpenCHVote}, which has a version
of the TW algorithm, except with width = 1, so we use vectors instead of matrices.
Otherwise we switch notation to as above, to make it easier to compare.

\subsection*{Pedersen Commitments}

For a set of messages $\textbf{m}=(m_{1}..m_{n})\in Z_{q}$, the \emph{Extended
Pedersen committment} to $\textbf{m}$ is

\begin{align*}
Commit(\textbf{m},pn)=g^{pn}*h_{1}^{m_{1}}*h_{2}^{m_{2}}*..h_{n}^{m_{n}}=g^{pn}*\prod_{i=1}^{n}h_{i}^{m_{i}}
\end{align*}

where ($g,\textbf{h}$) are generators of $Z_{p}^{r}$ and $pn$ is
the randomization nonce $\in Z_{q}$.

If $\textbf{b}_{i}$ is the $i^{th}$ column of $B_{\psi}$, then
the \emph{permutation commitment to $\psi$} is defined as the vector
of committments to its columns:

\[
Commit(\psi,\vec{pn})=(Commit(\textbf{b}_{1},pn_{1}),Commit(\textbf{b}_{2},pn_{2}),..Commit(\textbf{b}_{N},pn_{N}))=
\]

and

\begin{align*}
c_{j}=Commit(\textbf{b}_{j},pn_{j})=g^{pn_{j}}*\prod_{i=1}^{n}h_{i}^{b_{ij}}=g^{pn_{j}}*h_{i},\ for\ i=\psi^{-1}(j)
\end{align*}


\subsection*{Mix}

Choose a random permutation $\psi$ : (1..n) (1..n).

Then a mix is a permutation of rencryptions:

\[
w_{j}^{\prime}=Rencrypt(w_{i},r_{i}),\ j=\psi(i)
\]

or

\[
\vec{w}^{\prime}=\psi(Reencrypt(\vec{w},\vec{r}))
\]


\subsection*{Proof of permutation}

Let \textbf{u} = $Commit(\psi,\vec{pn})$ = $(u_{1},u_{2},..u_{N})$,
with randomization vector $\vec{pn}$ = $(pn_{1},pn_{2},..pn_{N})$,
and define $pnbar=\sum_{i=1}^{n}pn_{i}$.

$Condition$ 1 implies that

\[
\prod_{j=1}^{n}u_{j}=\prod_{j=1}^{n}g^{pn_{j}}\prod_{i=1}^{n}h_{i}^{b_{ij}}=g^{pnbar}\prod_{i=1}^{n}h_{i}\ =Commit(\textbf{1},pnbar).\ \ \ (5.2)
\]

Let $\vec{e}=(e_{1}..e_{n})$ be arbitrary values $\in Z_{q},\ \vec{e^{\prime}}$
its permutation by $\psi$, and $pne=\sum_{j=1}^{N}{pn_{j}\cdot e_{j}}$.

$Condition$ 2 implies that:

\[
\prod_{i=1}^{n}e_{i}=\prod_{j=1}^{n}e_{i}^{\prime}\ \ \ (5.3)
\]

\[
\prod_{j=1}^{n}u_{j}^{e_{j}}=\prod_{j=1}^{n}(g^{pn_{j}}\prod_{i=1}^{n}h_{i}^{b_{ij}})^{e_{j}}=g^{pne}\prod_{i=1}^{n}h_{i}^{pe_{i}}\ =Commit(\vec{e^{\prime}},pne)\ \ \ (5.4)
\]

Which constitutes proof that condition 1 and 2 are true, so that u
is a commitment to a permutation matrix.

\subsection*{Proof of equal exponents}

Let $\vec{m}$ be a vector of messages, $\vec{w}$ their encryptions
= Encr($\vec{m}$), and Reencrypt($\vec{w},\vec{r}$) their reencryptions
with nonces $\vec{r}$.

\[
\vec{w^{\prime}}=\psi(Reencr(\vec{w},\vec{r}))
\]

where, for j = $\psi(i)$

\[
w_{j}^{\prime}=ReEncr(w_{i},r_{i})=Encr(0,r_{i})\cdot w_{i}
\]

As above, let $\vec{e}=(e_{1}..e_{n})$ be arbitrary values $\in Z_{q}$,
and $\vec{e^{\prime}}$ its permutation by $\psi$. Note that $e_{j}^{\prime}=e_{i}$
for j = $\psi(i)$.

If the shuffle is valid, then

\begin{align*}
\prod_{j=1}^{n}(w_{j}^{\prime})^{e_{j}^{\prime}} & =\prod_{j=1}^{n}(Encr(0,r_{i})\cdot w_{i})^{e_{j}^{\prime}},\ i=\psi^{-1}(j)\\
 & =\prod_{j=1}^{n}(Encr(0,r_{i})\cdot w_{i})^{e_{i}}\ \ \ \ \ (from\ e_{j}^{\prime}=e_{i})\\
 & =Encr(0,\sum_{j=1}^{n}(r_{i}\cdot e_{i}))\prod_{j=1}^{n}w_{i}^{e_{i}}\ \ \ \ (from\ Equation\ 1)\\
 & =Encr(0,sumre)\cdot\prod_{j=1}^{n}w_{i}^{e_{i}}\ \ \ \ (5.5)\\
\end{align*}

where $sumre=\sum_{j=1}^{n}(r_{i}\cdot e_{i})$ = $\sum_{i=1}^{n}(r_{i}\cdot e_{i})$.

\section{Shuffling vectors}

\subsection*{Simple}

Much of the literature assumes that each row to be mixed consists
of a single ciphertext. In our application we need the possibility
that each row consists of a vector of ciphertexts.\\
 So for each row i, we now have a vector of \emph{w = width} ciphertexts:

\[
\textbf{e}_{i}=(e_{i,1},..e_{i,w})=\{e_{i,k}\},\ k=1..w
\]

The main work is to modify the proof of equal exponents for this case.

Suppose we are looking for the simplest generalization of 5.5:

\[
\prod_{j=1}^{n}pre_{j}^{pu_{j}}=Encr(0,sumru)\cdot\prod_{i=1}^{n}e_{i}^{u_{i}}\ \ \ (5.5)
\]

one could use the same nonce for all the ciphertexts in each row when
reencrypting:

\[
\textbf{r}=\{r_{j}\},j=1..nre_{j,k}=ReEncr(e_{j,k},r_{j})=Encr(0,r_{j})\cdot e_{j,k}\ \ \ (case1)
\]

or generate N = nrows {*} width nonces, one for each ciphertext:

\[
\textbf{r}=\{r_{j,k}\},\ j=1..n,\ k=1..wre_{j,k}=ReEncr(e_{j,k},r_{j,k})=Encr(0,r_{j,k})\cdot e_{j,k}\ \ \ (case2)
\]

Then eq 5.5 is changed to

\[
\prod_{j=1}^{n}\prod_{k=1}^{w}pre_{j,k}^{pu_{j}}=Encr(0,sumru')*\prod_{i=1}^{n}\prod_{k=1}^{w}e_{i,k}^{u_{i}}
\]

where, now

\[
sumru'=\sum_{j=1}^{n}width*(pr_{j}*pu_{j})\ \ \ (case1)=\sum_{j=1}^{n}\sum_{k=1}^{n}(pr_{j,k}*pu_{j})\ \ \ (case2).
\]

In algorithms 8.4, 8.5 of \cite{Haenni23}, the challenge includes a list of
all the ciphertexts and their reencryptions in their hash function:

\[
\textbf{u}=Hash(...,\textbf{e},\textbf{pe},pcommit,pkq,i,...)
\]

Here we just flatten the list of lists of ciphertexts for $\textbf{e},\textbf{pe}$,
so that all are included in the hash. Since the hash is dependent
on the ordering of the hash elements, this should preclude an attack
that switches ciphertexts within a row.

\subsection*{Haines Proof of vector shuffling}

Haines \cite{Haines19} gives a formal proof of security of TW when the shuffle
involves vectors of ciphertexts.

We will use the notation above for case 2, using a separate nonce
for each ciphertext:

\[
\textbf{r}=\{r_{j,k}\},\ j=1..n,\ k=1..wre_{j,k}=ReEncr(e_{j,k},r_{j,k})=Encr(0,r_{j,k})\cdot e_{j,k}\ \ \ (case2)
\]

This gives an nrows x width matrix R of reencryption nonces. The vector
notation is a shorthand for component-wise operations:

\[
R=(\textbf{r}_{1},..\textbf{r}_{n})Encr(\textbf{e}_{i})=(Encr(e_{i,1}),..Encr(e_{i,w}))ReEncr(\textbf{e}_{i},\textbf{r}_{i})=(ReEncr(e_{i,1},r_{i,1}),..ReEncr(e_{i,1},r_{i,w}))
\]

so now we have vector equations for rencryption:

\[
\textbf{re}_{i}=ReEncr(\textbf{e}_{i},\textbf{r}_{i})=Encr(0,\textbf{r}_{i})*\textbf{e}_{i}
\]

and the permuted form, as is returned by the shuffle:

\[
\textbf{pre}_{j}=ReEncr(\textbf{pe}_{j},\textbf{pr}_{j})=Encr(0,\textbf{pr}_{j})*\textbf{e}_{j}
\]

which corresponds to ntnu equation (p 3) of \cite{Haines19}:

\[
\textbf{e}_{i}^{\prime}=ReEnc(\textbf{e}_{\pi(i)},R_{\pi(i)}),\pi=\pi_{M}
\]

Let $\omega$ be width random nonces, \textbf{omega'} = permuted \textbf{omega},
and $\textbf{pe}_{i}$ = permuted $\textbf{e}_{i}=\textbf{e}_{i}^{\prime}$
as before. Then the $t_{4}$ equation (p 3, paragraph 2 of \cite{Haines19}
is a vector of width components:

\[
\textbf{t}_{4}=ReEnc(\prod_{i}^{n}\textbf{pe}_{i}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}},-\textbf{\ensuremath{\omega}}_{4})=(ReEnc(\prod_{i}^{n}\textbf{pe}_{i}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}},-\textbf{\ensuremath{\omega}}_{4,1}),..(ReEnc(\prod_{i}^{n}\textbf{pe}_{i}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}},-\textbf{\ensuremath{\omega}}_{4,w}))
\]

where

\[
\prod_{i}^{n}\textbf{pe}_{i}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}}
\]

must be the product over rows of the $k_{th}$ ciphertext in each
row:

\[
(\prod_{i}^{n}\textbf{pe}_{i,1}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}},..\prod_{i}^{n}\textbf{pe}_{i,w}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}})=\{\prod_{i}^{n}\textbf{pe}_{i,k}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}}\},k=1..width\textbf{t}_{4}=\{Rencr(\prod_{i}^{n}\textbf{pe}_{i,k}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}},-\textbf{\ensuremath{\omega}}_{4})\},k=1..width
\]

(quite a bit more complicated than our simplest thing to do above)

\subsection*{extra}

to go back to (2f) and unravel this:

\[
\prod_{j=1}^{n}ReEncr(e_{j},r_{j})=ReEncr(\prod_{j=1}^{n}e_{j},\sum_{j=1}^{n}r_{j})\ \ \ (2f)\prod_{j=1}^{n}ReEncr(\textbf{pe}_{i}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}},r_{j})=ReEncr(\prod_{j=1}^{n}\textbf{pe}_{i}^{\textbf{\ensuremath{\omega}}_{i}^{\prime}},\sum_{j=1}^{n}r_{j})
\]


\section{Timings vs Verificatum (preliminary)}

Environment used for testing:
\begin{itemize}
\item Ubuntu 22.04.3 
\item HP Z840 Workstation, Intel Xeon CPU E5-2680 v3 @ 2.50GHz 
\item 24-cores, two threads per core. 
\end{itemize}
\subsubsection*{Regular vs accelerated exponentiation time}

Regular exponentiation is about 3 times slower after the acceleration
cache warms up:
\begin{verbatim}
acc took 15288 msec for 20000 = 0.7644 msec per acc
exp took 46018 msec for 20000 = 2.3009 msec per exp
exp/acc = 3.01007326007326
\end{verbatim}

\subsection*{VMN}

\subsubsection*{Operation counts}
\begin{itemize}
\item \emph{n} = number of rows, eg ballots or contests 
\item \emph{width} = number of ciphertexts per row 
\item \emph{N} = nrows {*} width = total number of ciphertexts to be mixed 
\end{itemize}

\begin{longtable}[c]{@{}lllll@{}}
\toprule 
 & shuffle  & proof of shuffle  & proof of exp  & verify\tabularnewline
\endhead
\midrule 
regular exps  & 0  & 4 {*} n  & 2 {*} N  & 4{*}N + 4 {*} n + 4\tabularnewline
accelerated exps  & 2 {*} N  & 3 {*} n + 2 {*} width + 4  & 0  & n + 2{*}width + 3\tabularnewline
\bottomrule
\end{longtable}

Even though N dominates, width is bound but nrows can get arbitrarily
big.

The proof of shuffle could be done "offline", though intermediate
values would have to be kept private (I think).

Could break into batches of 100-1000 ballots each and do each batch
in parallel. The advantage here is that there would be complete parallelization.

\subsection*{Timing results}

See \href{https://docs.google.com/spreadsheets/d/1Sny1xXxU9vjPnqo2K1QPeBHQwPVWhJOHdlXocMimt88/edit?usp=sharing}{VMN spreadsheets}for
graphs of timing results (work in progress).

\subsection*{OpenChVote}

\textbf{operations count}

\begin{longtable}[c]{@{}llll@{}}
\toprule 
 & shuffle  & proof  & verify\tabularnewline
\endhead
\midrule 
regular exps  & 0  & 6 {*} n  & 6{*}n + 6\tabularnewline
accelerated exps  & 2 {*} N  & 3{*}n + 6  & n + 6\tabularnewline
\bottomrule
\end{longtable}

\textbf{wallclock time vs verificatum}

nrows = 1000, width = 34, N=3400
\begin{verbatim}
Time verificatum as used by rave

RunMixnet elapsed time = 67598 msecs
RunMixnet elapsed time = 67853 msecs)
RunMixnetVerifier elapsed time = 68855 msecs
RunMixnetVerifier elapsed time = 68738 msecs
nrows=1000, width= 34 per row, N=34000, nthreads=24

shuffle: took 5511 msecs
proof: took 12944 msecs
verify: took 27983 msecs
total: took 46438 msecs
\end{verbatim}
nrows = 100, width = 34, N=3400
\begin{verbatim}
Time verificatum as used by rave

RunMixnet elapsed time = 27831 msecs
RunMixnet elapsed time = 26464 msecs)
RunMixnetVerifier elapsed time = 12123 msecs
RunMixnetVerifier elapsed time = 12893 msecs

total = 79.311 secs
Time egk-mixnet

  shuffle1 took 5505
  shuffleProof1 took 17592
  shuffleVerify1 took 33355
  shuffle2 took 5400
  shuffleProof2 took 17213
  shuffleVerify1 took 33446
  
  total: 119.711 secs, N=3400 perN=35 msecs
\end{verbatim}
Vmn proof 27/(17.4+5.4) = 1.18 is 18\% slower

Vmn has verifier 33355/12123 = 2.75 faster, TODO: investigate if theres
an algorithm improvement there. Possibly related to the "wide integer"
representation, eg see
\begin{verbatim}
LargeInteger.modPowProd(LargeInteger[] bases, LargeInteger[] exponents, LargeInteger modulus)
\end{verbatim}
More likely there are parallelization being done, eg in the same routine.
So to compare, we have to run vmn and see what parelization it gets.

Also note LargeInteger.magic that allows use of VMGJ.

Vmn in pure Java mode, using BigInteger. TODO: Find out how much speedup
using VMGJ gets.

SO why doesnt same speedup apply to proof?

\begin{thebibliography}{999}

\bibitem{Wikstr10} 
  B. Terelius and D. Wikström. 
  \emph{Proofs of restricted shuffles},
  In D. J. Bernstein and T. Lange, editors, AFRICACRYPT'10, 
  3rd International Conference on Cryptology inAfrica, LNCS 6055, pages 100--113, 
  Stellenbosch, South Africa, 2010. 

\bibitem{Wikstr09} D. Wikström. 
  \emph{A commitment-consistent proof of a shuffle.} 
  In C. Boyd and J. González Nieto, editors, 
  ACISP'09, 14th Australasian Conference on Information Security and Privacy, LNCS 5594, pages 407--421,
  Brisbane, Australia, 2009. 

\bibitem{Wikstr22} D. Wikström. 
  \emph{How to Implement a Stand-alone Verifier for the Verificatum Mix-Net VMN Version 3.1.0},
  2022-09-10, 
  \url{https://www.verificatum.org/files/vmnv-3.1.0.pdf}.

\bibitem{Verificatum} D. Wikström. 
  \emph{Verificatum Mix-Net},
  \url{https://github.com/verificatum/verificatum-vmn}.

\bibitem{Haenni23} 
  Rolf Haenni, Reto E. Koenig, Philipp Locher, Eric Dubuis,
  \emph{CHVote Protocol Specification Version 3.5}, 
  Bern University of Applied Sciences,
  February 28th, 2023, 
  \url{https://eprint.iacr.org/2017/325.pdf} 
  
\bibitem{Haenni17} 
  R. Haenni, P. Locher, R. E. Koenig, and E. Dubuis,
  \emph{Pseudo-code algorithms for verifiable re-encryption mix-nets},
  In M. Brenner, K. Rohloff, J. Bonneau, A. Miller, P. Y. A.Ryan, V. Teague, A. Bracciali, M. Sala, F. Pintore, and M. Jakobsson, editors, 
  FC'17, 21st International Conference on Financial Cryptography, LNCS 10323, pages 370--384,
  Silema, Malta, 2017. 
  
\bibitem{OpenCHVote}
\emph{OpenCHVote}
  E-Voting Group, Institute for Cybersecurity and Engineering, 
  Bern University of Applied Sciences, 
  \url{https://gitlab.com/openchvote/cryptographic-protocol} 

\bibitem{Haines19}
  Thomas Haines, 
  \emph{A Description and Proof of a Generalised and Optimised Variant of Wikström's Mixnet}, arXiv:1901.08371v1 {[}cs.CR{]},
  24 Jan 2019.

\bibitem{Benaloh23}
  Josh Benaloh and Michael Naehrig,
  \emph{ElectionGuard Design Specification, Version 2.0.0},
  Microsoft Research, 
  August 18, 2023,
  \url{https://github.com/microsoft/electionguard/releases/download/v2.0/EG\_Spec\_2\_0.pdf}.
  
\bibitem{Caron23} 
  John Caron, Dan Wallach, 
  \emph{ElectionGuard Kotlin library}, 
  \url{https://github.com/votingworks/electionguard-kotlin-multiplatform}.
  
\end{thebibliography}

\pagebreak
\subsection*{Alternative Calculation of B}

The calculation of B (use $e$ instead of $e^{\prime}$ here for notational simplicity):

\begin{align*}
B_{0} &= g^{b_0} h_0^{e_{0}} \\
B_i & =g^{b_{i}}(B_{i-1})^{e_{i}},\ i=1..n \\
\end{align*}

can be done to only use accelerated exponents . Expand the series:

\begin{align*}
B_0 &= g^{b_0} h_0^{e_{0}} \\
B_1 & = g^{b_1}(B_0)^{e_1} = g^{b_1 + b_0 e_1} \cdot h_0^{e_0 \cdot e_1} \\
B_2 & = g^{b_2}(B_1)^{e_2} = g^{b_2 + (b_1 + b_0 e_1) e_2} \cdot h_0^{e_0 \cdot e_1 \cdot e_2} \\
... \\
B_i & = g^{b_i}(B_{i-1})^{e_i} = g^{gexps_i} \cdot h_0^{hexps_i} \\
\end{align*}

where

\begin{align*}
gexps_i &= b_i + (gexps_{i-1}) \cdot e_i \\
hexps_i &= \prod_{j=1}^{i} e_j
\end{align*}

Then each row has 2 accelerated exponentiations.

\subsection*{Alternative Calculation of B'}

Similarly $B^{\prime}$:

\begin{align*}
B_{1}^{\prime} &= g^{\beta_1} h_0^{eps_1} \\
B_{i}^{\prime} &= g^{\beta_{i}}(B_{i-1})^{eps_{i}},\ i=2..n \\
\end{align*}

can be done with only accelerated exponentiations:

\begin{align*}
B_1^{\prime} &= g^{\beta_1} h_0^{eps_1} \\
B_i^{\prime} &= g^{beta_i}(B_{i-1})^{eps_i} = g^{gpexps_i} \cdot h_0^{hpexps_i} \\
\end{align*}

where

\begin{align*}
gpexps_i &= \beta_i + (gexps_{i-1}) \cdot eps_i \\
hpexps_i &= hexps_{i-1} \cdot eps_i
\end{align*}

\end{document}
