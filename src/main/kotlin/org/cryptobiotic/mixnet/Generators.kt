package org.cryptobiotic.mixnet

import org.cryptobiotic.eg.core.*
import org.cryptobiotic.eg.core.ecgroup.EcElementModP
import org.cryptobiotic.eg.core.ecgroup.EcGroupContext
import org.cryptobiotic.eg.core.ecgroup.EcGroupContext.Companion.statBytesP
import org.cryptobiotic.eg.core.ecgroup.EcGroupContext.Companion.statBytesQ
import org.cryptobiotic.eg.core.ecgroup.RFC9380
import org.cryptobiotic.eg.core.ecgroup.VecGroup.Companion.jacobiSymbol
import org.cryptobiotic.eg.core.intgroup.IntElementModP
import org.cryptobiotic.eg.core.intgroup.IntGroupContext
import org.cryptobiotic.eg.election.GroupType
import org.cryptobiotic.eg.election.parameterBaseHash
import org.cryptobiotic.maths.*
import java.math.BigInteger
import kotlin.math.min

// generate a set of n independent generators with a reproducible algorithm

fun getGenerators(group: GroupContext, n: Int, mixName: String): VectorP {
    // This corresponds to RO_seed(rho, "generators") in section 8.2.
    // TODO beef up the seed parameters?
    val seed = parameterBaseHash(group.constants).bytes
    val prg = PRGsequence(group, seed, mixName)

    return if (group.constants.type == GroupType.IntegerGroup) getGeneratorsInt(group, n, prg)
           else getGeneratorsEC(group, n, prg)
}

// VMN section 6.8 "Multiplicative Group"
fun getGeneratorsInt(group: GroupContext, numberOfGenerators: Int, prgSeq: PRGsequence): VectorP {
    val nbytes = group.MAX_BYTES_P + statBytesQ

    val intGroup = group as IntGroupContext
    val exp = (intGroup.p - BigInteger.ONE).div(intGroup.q) // (p-1)/q

    val result = mutableListOf<ElementModP>()
    while (result.size < numberOfGenerators) {
        val ba = prgSeq.next(nbytes)
        val bi = BigInteger(1, ba)
        val ti = bi.modPow(exp, intGroup.p)
        result.add(IntElementModP(ti, intGroup))
    }
    return VectorP(group, result)
}

// VMN section 6.8 "Elliptic curves over prime order fields", but using rfc9380 to get uniform hashing
fun getGeneratorsEC(group: GroupContext, numberOfGenerators: Int, prgSeq: PRGsequence): VectorP {
    val ecGroup = group as EcGroupContext
    val rfc9380 = RFC9380(ecGroup, "QUUX-V01-CS02-with-P256_XMD:SHA-256_SSWU_RO_".toByteArray(), statBytesP /8)
    val vecGroup = ecGroup.vecGroup

    val result = mutableListOf<ElementModP>()
    while (result.size < numberOfGenerators) {
        val ba = prgSeq.next(ecGroup.vecGroup.pbyteLength) // dont need extra bits yet
        val ba2 = rfc9380.expand_message(ba) // extra bits are here
        val bi = BigInteger(1, ba2)
        val zi = bi.mod(vecGroup.primeModulus)

        // could alternatively use rfc9380 section 6.2.2
        val fx = vecGroup.equationf(zi)
        if (jacobiSymbol(fx, vecGroup.primeModulus) == 1) {
            val y2 = vecGroup.sqrt(fx) // TODO find smaller root?? Doesnt seem necessary
            val ec = vecGroup.makeVecModP(zi, y2)
            result.add(EcElementModP(ecGroup, ec))
        }
    }
    return VectorP(group, result)
}

class PRGsequence(group: GroupContext, seed: ByteArray, name: String) {
    val prg = PRG(group, seed, name)
    var nextIndex = 1

    fun next(sizeBytes: Int) : ByteArray {
        val ba = ByteArray(sizeBytes)
        nextIndex = prg.getBytes(ba, nextIndex)
        return ba
    }
}

/** Psuedo Random Generator. */
class PRG(val group: GroupContext, seed: ByteArray, name: String) {
    val internalSeed = hashFunction(seed, 0x53.toByte(), name).bytes

    // generate a psuedo-random array of bytes of size result.size
    // put the generated bytes in result; return the ending index
    fun getBytes(result: ByteArray, startIndex : Int = 1): Int {
        val nbytes = result.size
        var index = startIndex
        var bytesLeft = nbytes
        while (bytesLeft > 0) {
            val nextHash = hashFunction(internalSeed, index)
            val hashBytes = group.hashToElementModQ(nextHash).byteArray()
            val need = min(hashBytes.size, bytesLeft)
            System.arraycopy(hashBytes, 0, result, nbytes - bytesLeft, need)
            bytesLeft -= need
            index++
        }
        // println("start = $startIndex end = $index")
        return index
    }
}